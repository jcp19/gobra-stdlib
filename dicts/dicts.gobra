/*
  This file is part of gobra-libs which is released under the MIT license.
  See LICENSE or go to https://github.com/viperproject/gobra-libs/blob/main/LICENSE
  for full license details.

  This file is inspired by the standard libraries and axiomatisations of the following verifiers:
  - dafny-lang/dafny: https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/src/Std/Collections/Map.dfy
  - verus-lang/verus:
    - https://github.com/verus-lang/verus/blob/main/source/pervasive/map_lib.rs
    - https://github.com/verus-lang/verus/blob/main/source/pervasive/map.rs
*/

// This package defines lemmas for mathematical maps (aka dictionaries) commonly used
// in specifications.
package dicts

import "util"
import "sets"

/// Dafny
// Skip Get: No Option<>
// Skip ToImap: No Imap

// A dictionary is empty if its (domain's) cardinality is zero.
ghost
decreases
pure func IsEmpty(d dict[int]int) bool {
	return len(d) == 0
}

// Returns the empty dictionary.
ghost
ensures IsEmpty(result)
decreases
pure func Empty() (result dict[int]int) {
	return dict[int]int{}
}

// QUES We structure Remove, RemoveKeys and Restrict a bit differently
// than Dafny. Are the differences ok?

// Keep all key-value pairs corresponding to the set of keys provided.
ghost
ensures forall x int :: {result[x]} (x in domain(d) && x in xs) ==>
	(x in domain(result) && result[x] == d[x])
ensures forall x int :: {x in domain(result)} x in domain(result) ==>
	(x in domain(d) && x in xs)
ensures domain(result) == xs intersection domain(d)
opaque
decreases xs
pure func Restrict(d dict[int]int, xs set[int]) (result dict[int]int) {
	return let ys := (xs intersection domain(d)) in
		(sets.IsEmpty(ys) ? Empty() :
			(let y := sets.Choose(ys) in
			(let yr := sets.Remove(ys, y) in
			(let _ := sets.IntersectLenUpper(xs, domain(d)) in
			 Restrict(d, yr)[y = d[y]]))))
}

// Remove all key-value pairs corresponding to the set of keys provided.
ghost
decreases
pure func RemoveKeys(d dict[int]int, xs set[int]) (result dict[int]int) {
	return Restrict(d, domain(d) setminus xs)
}

// Remove a key-value pair. Returns unmodified dictionary if key is not found.
ghost
ensures len(result) <= len(d)
ensures x in domain(d) ==> len(result) == len(d) - 1
ensures !(x in domain(d)) ==> len(result) == len(d)
decreases
// QUES For these properties a proof is required. There are few things we can do:
// - Separate properties into different lemma: Calling remove doesnt call its proof, but it is less convenient.
// - Make RemoveKeys(d, sets.SingletonSet(x)) part of the spec and make the function opaque:
//   This would make the API a bit inconsistent (RemoveKeys for example doesn't have that) - although we could change RemoveKeys accordingly (seems like this is what Dafny does)
// - Keep it as is: Whenever someone calls Remove, the proof is instantiated as well.
pure func Remove(d dict[int]int, x int) (result dict[int]int) {
	return let ys := (sets.Remove(domain(d), x)) in
		let _ := util.Asserting(ys intersection domain(d) == ys) in
		RemoveKeys(d, sets.SingletonSet(x))
}

// True iff x maps to the same value or does not exist in d1 and d2.
ghost
decreases
pure func IsEqualOnKey(d1, d2 dict[int]int, x int) bool {
	return !(x in domain(d1) || x in domain(d2)) || (x in domain(d1) && x in domain(d2) && d1[x] == d2[x])
}

// True iff and only if d1 is a subset of d2.
ghost
decreases
pure func IsSubset(d1, d2 dict[int]int) bool {
	return domain(d1) subset domain(d2) &&
		forall x int :: {IsEqualOnKey(d1, d2, x)} {x in domain(d1)} (x in domain(d1)) ==>
		IsEqualOnKey(d1, d2, x)
}

// Union of two dictionaries. Does not require disjoint domains: on the intersection,
// values from the second dictionary are chosen.
ghost
ensures domain(result) == domain(d1) union domain(d2)
ensures forall x int :: {result[x]} (x in domain(d2)) ==> result[x] == d2[x]
ensures forall x int :: {result[x]}  (!(x in domain(d2)) && x in domain(d1)) ==>
	result[x] == d1[x]
opaque
decreases domain(d1) union domain(d2)
pure func Union(d1, d2 dict[int]int) (result dict[int]int) {
	return let xs := domain(d1) union domain(d2) in
		(sets.IsEmpty(xs) ? Empty() :
			let x := sets.Choose(xs) in
			let c1 := Remove(d1, x) in
			let c2 := Remove(d2, x) in
			let _ := sets.RemoveUnionLen(domain(d1), domain(d2), x) in
			(x in domain(d2) ? Union(c1, c2)[x = d2[x]] : Union(c1, c2)[x = d1[x]]))
}

ghost
requires sets.AreDisjoint(domain(d1), domain(d2))
ensures len(Union(d1, d2)) == len(d1) + len(d2)
decreases
pure func DisjointUnionLen(d1, d2 dict[int]int) util.Unit {
	return util.Unit{}
}

// True iff a dictionary is injective.
ghost
opaque
decreases
pure func IsInjective(d dict[int]int) bool {
	return forall x, y int :: {d[x], d[y]} (x != y && x in domain(d) && y in domain(d)) ==>
		d[x] != d[y]
}

/// TODO Invert seems to be a bit involved. Skipping it for now.
// TODO: Go through the Dafny version again, which is quite different.
// Dafny's Invert is opaque and has
// map y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x as its body.
// TODO: make opaque?
// Swap dictionary keys and values. Values are not required to be unique: no promises
// on which key is chosen on the intersection.
// ghost
// ensures domain(result) == range(d)
// // I think the following follows from the forall
// // ensures range(result) subset domain(d)
// // QUES Maybe {d[result[x]]} instead?
// // ensures forall x int :: {result[x]} x in domain(result) ==> d[result[x]] == x
// // QUES Shouldn't decreases d be equivalent to this (or at least fail type checking?)
// decreases len(d)
// func Invert(d dict[int]int) (result dict[int]int) {
// 	if IsEmpty(d) {
// 		result := Empty()
// 		assert domain(result) == range(d)
// 		return result
// 	} else {
// 		key := sets.Choose(domain(d))
// 		c := Remove(d, key)
// 		invertC := Invert(c)
// 		result := invertC[d[key] = key]
// 		assert domain(result) == sets.Add(domain(invertC), d[key])
// 		assert sets.Add(domain(invertC), d[key]) == sets.Add(range(c), d[key])
// 		assert range(c) == sets.Remove(range(d), key)
// 		assert sets.Add(range(c), d[key]) == range(d)
// 		return result
// 	}
// }

// I feel like I need this helper for Invert
// ghost
// requires key in domain(d)
// ensures sets.Add(range(Remove(d, key)), d[key]) == range(d)
// decreases
// func Helper(d dict[int]int, key int) {
// 	assert d[key] in range(d)
// 	temp := Remove(d, key)
// 	// != corresponds to XOR (i think); fails atm
// 	assert (range(temp) == range(d)) != (range(temp) == sets.Remove(range(d), key))
// }

// TODO Prove this
// Inverted dictionaries are injective.
// ghost
// ensures IsInjective(Invert(d))
// decreases
// func InvertIsInjective(d dict[int]int) {
// 	inverted := reveal Invert(d)
// 	reveal IsInjective(inverted)
// }

// True iff a dictionary contains all valid keys.
ghost
opaque
decreases
pure func Total(d dict[int]int) bool {
	return forall x int :: {d[x]} {x in domain(d)} x in domain(d)
}

// True iff a dictionary is monotonic.
ghost
opaque
decreases
pure func IsMonotonic(d dict[int]int) bool {
	return forall x, y int :: {d[x], d[y]} (x in domain(d) && y in domain(d) && x <= y) ==>
		d[x] <= d[y]
}

// True iff a dictionary is monotonic. Only considers keys greater than or equal to start.
ghost
opaque
decreases
pure func IsMonotonicFrom(d dict[int]int, start int) bool {
	return forall x, y int :: {d[x], d[y]} (x in domain(d) && y in domain(d) && start <= x && x <= y) ==>
		d[x] <= d[y]

}
// Verus: map_lib.rs
// is_full -> Total
// is_empty -> IsEmpty
// contains_key(dict, key) -> key in domain(dict)
// contains_value(dict, value) -> value in range(dict)
// values(dict) -> domain(dict)
// contains_pair(dict, key, value) -> dict[key] == value
// submap_of, spec_le, le -> IsSubset
// union_prefer_right -> Union
// remove_keys -> RemoveKeys
// restrict -> Restrict
// is_equal_on_key -> IsEqualOnKey

// True iff d1 and d2 agree on all keys that their domains share.
ghost
decreases
pure func Agree(d1, d2 dict[int]int) bool {
	return forall x int :: {d1[x], d2[x]} x in (domain(d1) intersection domain(d2)) ==>
		d1[x] == d2[x]
}

// map_entries: skip (no higher order functions)
// map_values: skip (no higher order functions)
// invert -> Invert
// lemma_remove_key_len: part of Remove's spec

// QUES Do we want this lemma? Not sure whether it is useful.
// The domain of a map after removing a key is equivalent to removing
// the key from the domain of the original map.
ghost
ensures domain(Remove(d, key)) == sets.Remove(domain(d), key)
decreases
pure func RemoveEquivalency(d dict[int]int, key int) util.Unit {
	return util.Unit{}
}

// TODO RemoveKeysLen
// QUES Should this be a separate lemma or part of RemoveKeys?
// QUES Should we prove properties for Restrict?

// lemma_invert_is_injective -> InvertIsInjective
// is_monotonic -> IsMonotonic
// is_monotonic_from -> IsMonotonicFrom
// lemma_disjoint_union_size -> DisjointUnionLen
// lemma_map_new_domain: skip (construction not applicable)
// lemma_map_new_values: skip (construction not applicable)
// lemma_map_properties: skip (previous two quantified)
// lemma_values_finite: skip (no infinite dicts)

// Verus: map.rs

