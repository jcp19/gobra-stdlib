/*
  This file is part of gobra-libs which is released under the MIT license.
  See LICENSE or go to https://github.com/viperproject/gobra-libs/blob/main/LICENSE
  for full license details.

  This file is inspired by the standard libraries and axiomatisations of the following verifiers:
  - dafny-lang/dafny: https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/src/Std/Collections/Map.dfy
  - verus-lang/verus:
    - https://github.com/verus-lang/verus/blob/main/source/pervasive/map_lib.rs
    - https://github.com/verus-lang/verus/blob/main/source/pervasive/map.rs
  - viperproject/silicon: https://github.com/viperproject/silicon/blob/master/src/main/resources/dafny_axioms/maps.vpr
  - why3:
    - https://www.why3.org/stdlib/fmap.html
    - https://www.why3.org/stdlib/map.html
*/

// This package defines lemmas for mathematical maps (aka dictionaries) commonly used
// in specifications.
package dicts

import "util"
import "sets"

/// Dafny
// Skip Get: No Option<>
// Skip ToImap: No Imap

// A dictionary is empty if its domain is empty.
ghost
decreases
pure func IsEmpty(d dict[int]int) bool {
	return sets.IsEmpty(domain(d))
}

// Returns the empty dictionary.
ghost
ensures IsEmpty(result)
decreases
pure func Empty() (result dict[int]int) {
	return dict[int]int{}
}

// QUES We structure Remove, RemoveKeys and Restrict a bit differently
// than Dafny. Are the differences ok?

// Keep all key-value pairs corresponding to the set of keys provided.
ghost
ensures forall x int :: {result[x]} (x in domain(d) && x in xs) ==>
	(x in domain(result) && result[x] == d[x])
ensures forall x int :: {x in domain(result)} x in domain(result) ==>
	(x in domain(d) && x in xs)
ensures domain(result) == xs intersection domain(d)
opaque
decreases xs
pure func Restrict(d dict[int]int, xs set[int]) (result dict[int]int) {
	return let ys := (xs intersection domain(d)) in
		(sets.IsEmpty(ys) ? Empty() :
			(let y := sets.Choose(ys) in
			(let yr := sets.Remove(ys, y) in
			(let _ := sets.IntersectLenUpper(xs, domain(d)) in
			 Restrict(d, yr)[y = d[y]]))))
}

// Remove all key-value pairs corresponding to the set of keys provided.
ghost
decreases
pure func RemoveKeys(d dict[int]int, xs set[int]) (result dict[int]int) {
	return Restrict(d, domain(d) setminus xs)
}

// Remove a key-value pair. Returns unmodified dictionary if key is not found.
ghost
ensures len(result) <= len(d)
ensures x in domain(d) ==> len(result) == len(d) - 1
ensures !(x in domain(d)) ==> len(result) == len(d)
decreases
// QUES For these properties a proof is required. There are few things we can do:
// - Separate properties into different lemma: Calling remove doesnt call its proof, but it is less convenient.
// - Make RemoveKeys(d, sets.SingletonSet(x)) part of the spec and make the function opaque:
//   This would make the API a bit inconsistent (RemoveKeys for example doesn't have that) - although we could change RemoveKeys accordingly (seems like this is what Dafny does)
// - Keep it as is: Whenever someone calls Remove, the proof is instantiated as well.
pure func Remove(d dict[int]int, x int) (result dict[int]int) {
	return let ys := (sets.Remove(domain(d), x)) in
		let _ := util.Asserting(ys intersection domain(d) == ys) in
		RemoveKeys(d, sets.SingletonSet(x))
}

// True iff x maps to the same value or does not exist in d1 and d2.
ghost
decreases
pure func IsEqualOnKey(d1, d2 dict[int]int, x int) bool {
	return !(x in domain(d1) || x in domain(d2)) || (x in domain(d1) && x in domain(d2) && d1[x] == d2[x])
}

// True iff and only if d1 is a subset of d2.
ghost
decreases
pure func IsSubset(d1, d2 dict[int]int) bool {
	return domain(d1) subset domain(d2) &&
		forall x int :: {IsEqualOnKey(d1, d2, x)} {x in domain(d1)} (x in domain(d1)) ==>
		IsEqualOnKey(d1, d2, x)
}

// Union of two dictionaries. Does not require disjoint domains: on the intersection,
// values from the second dictionary are chosen.
ghost
ensures domain(result) == domain(d1) union domain(d2)
ensures forall x int :: {result[x]} (x in domain(d2)) ==> result[x] == d2[x]
ensures forall x int :: {result[x]}  (!(x in domain(d2)) && x in domain(d1)) ==>
	result[x] == d1[x]
opaque
decreases domain(d1) union domain(d2)
pure func Union(d1, d2 dict[int]int) (result dict[int]int) {
	return let xs := domain(d1) union domain(d2) in
		(sets.IsEmpty(xs) ? Empty() :
			let x := sets.Choose(xs) in
			let c1 := Remove(d1, x) in
			let c2 := Remove(d2, x) in
			let _ := sets.RemoveUnionLen(domain(d1), domain(d2), x) in
			(x in domain(d2) ? Union(c1, c2)[x = d2[x]] : Union(c1, c2)[x = d1[x]]))
}

// Dictionaries are disjoint iff their domains are disjoint.
ghost
decreases
pure func AreDisjoint(d1, d2 dict[int]int) bool {
	return sets.AreDisjoint(domain(d1), domain(d2))
}

// The length of the union of two disjoint dictionaries is the sum of each of their lengths.
ghost
requires AreDisjoint(d1, d2)
ensures len(Union(d1, d2)) == len(d1) + len(d2)
decreases
pure func DisjointUnionLen(d1, d2 dict[int]int) util.Unit {
	return util.Unit{}
}

// True iff a dictionary is injective.
ghost
opaque
decreases
pure func IsInjective(d dict[int]int) bool {
	return forall x, y int :: {d[x], d[y]} (x != y && x in domain(d) && y in domain(d)) ==>
		d[x] != d[y]
}

/// TODO Invert seems to be a bit involved. Skipping it for now.
// TODO: Go through the Dafny version again, which is quite different.
// Dafny's Invert is opaque and has
// map y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x as its body.
// TODO: make opaque?
// Swap dictionary keys and values. Values are not required to be unique: no promises
// on which key is chosen on the intersection.
// ghost
// ensures domain(result) == range(d)
// // I think the following follows from the forall
// // ensures range(result) subset domain(d)
// // QUES Maybe {d[result[x]]} instead?
// // ensures forall x int :: {result[x]} x in domain(result) ==> d[result[x]] == x
// // QUES Shouldn't decreases d be equivalent to this (or at least fail type checking?)
// decreases len(d)
// func Invert(d dict[int]int) (result dict[int]int) {
// 	if IsEmpty(d) {
// 		result := Empty()
// 		assert domain(result) == range(d)
// 		return result
// 	} else {
// 		key := sets.Choose(domain(d))
// 		c := Remove(d, key)
// 		invertC := Invert(c)
// 		result := invertC[d[key] = key]
// 		assert domain(result) == sets.Add(domain(invertC), d[key])
// 		assert sets.Add(domain(invertC), d[key]) == sets.Add(range(c), d[key])
// 		assert range(c) == sets.Remove(range(d), key)
// 		assert sets.Add(range(c), d[key]) == range(d)
// 		return result
// 	}
// }

// I feel like I need this helper for Invert
// ghost
// requires key in domain(d)
// ensures sets.Add(range(Remove(d, key)), d[key]) == range(d)
// decreases
// func Helper(d dict[int]int, key int) {
// 	assert d[key] in range(d)
// 	temp := Remove(d, key)
// 	// != corresponds to XOR (i think); fails atm
// 	assert (range(temp) == range(d)) != (range(temp) == sets.Remove(range(d), key))
// }

// TODO Prove this
// Inverted dictionaries are injective.
// ghost
// ensures IsInjective(Invert(d))
// decreases
// func InvertIsInjective(d dict[int]int) {
// 	inverted := reveal Invert(d)
// 	reveal IsInjective(inverted)
// }

// True iff a dictionary contains all valid keys.
ghost
opaque
decreases
pure func IsTotal(d dict[int]int) bool {
	return forall x int :: {d[x]} {x in domain(d)} x in domain(d)
}

// True iff a dictionary is monotonic.
ghost
opaque
decreases
pure func IsMonotonic(d dict[int]int) bool {
	return forall x, y int :: {d[x], d[y]} (x in domain(d) && y in domain(d) && x <= y) ==>
		d[x] <= d[y]
}

// True iff a dictionary is monotonic. Only considers keys greater than or equal to start.
ghost
opaque
decreases
pure func IsMonotonicFrom(d dict[int]int, start int) bool {
	return forall x, y int :: {d[x], d[y]} (x in domain(d) && y in domain(d) && start <= x && x <= y) ==>
		d[x] <= d[y]
}

// Verus: map_lib.rs
// is_full -> Total
// is_empty -> IsEmpty
// contains_key(dict, key) -> key in domain(dict)
// contains_value(dict, value) -> value in range(dict)
// values(dict) -> domain(dict)
// contains_pair(dict, key, value) -> dict[key] == value
// submap_of, spec_le, le -> IsSubset
// union_prefer_right -> Union
// remove_keys -> RemoveKeys
// restrict -> Restrict
// is_equal_on_key -> IsEqualOnKey

// True iff d1 and d2 agree on all keys that their domains share.
ghost
decreases
pure func Agree(d1, d2 dict[int]int) bool {
	return forall x int :: {d1[x], d2[x]} x in (domain(d1) intersection domain(d2)) ==>
		d1[x] == d2[x]
}

// map_entries: skip (no higher order functions)
// map_values: skip (no higher order functions)
// invert -> Invert
// lemma_remove_key_len: part of Remove's spec

// The domain of a map after removing a key is equivalent to removing
// the key from the domain of the original map.
ghost
ensures domain(Remove(d, key)) == sets.Remove(domain(d), key)
decreases
pure func RemoveDomain(d dict[int]int, key int) util.Unit {
	return util.Unit{}
}

// TODO RemoveKeysLen
// QUES Should this be a separate lemma or part of RemoveKeys?
// QUES Should we prove properties for Restrict?

// lemma_invert_is_injective -> InvertIsInjective
// is_monotonic -> IsMonotonic
// is_monotonic_from -> IsMonotonicFrom
// lemma_disjoint_union_size -> DisjointUnionLen
// lemma_map_new_domain: skip (construction not applicable)
// lemma_map_new_values: skip (construction not applicable)
// lemma_map_properties: skip (previous two quantified)
// lemma_values_finite: skip (no infinite dicts)

// Verus: map.rs
// empty -> Empty
// total: skip (construction not applicable)
// new: skip (construction not applicable)
// dom -> domain
// index, spec_index -> []
// insert(dict, key, value) -> dict[key = value]
// remove -> Remove
// len -> len
// tracked_*: skip (doesnt look applicable)
// axiom_map_index_decreases_*: skip (assuming its termination which we dont consider in the standard lib)

// NOTE: I am not really confident in the usefulness of these functions
// adapted from Verus' map.rs

// The domain of the empty dictionary is the empty set.
ghost
requires IsEmpty(d)
ensures domain(d) == sets.Empty()
decreases
pure func EmptyDictEmptyDomain(d dict[int]int) util.Unit {
	return util.Unit{}
}

// The domain of a dictionary after inserting a key-value pair is equivalent to
// inserting the key into the original map's domain set.
ghost
ensures domain(d[key = value]) == sets.Add(domain(d), key)
decreases
pure func InsertDomain(d dict[int]int, key, value int) util.Unit {
	return util.Unit{}
}

// Inserting value at key in d results in a dictionary that maps key to value.
ghost
ensures d[key = value][key] == value
decreases
pure func UpdateSame(d dict[int] int, key, value int) util.Unit {
	return util.Unit{}
}

// Inserting value at key2 does not change the value mapped to by any other keys in d.
ghost
requires key1 != key2
ensures key2 in domain(d[key1 = value]) == key2 in domain(d)
ensures key2 in domain(d) ==> d[key1 = value][key2] == d[key2]
decreases
pure func UpdateDifferent(d dict[int]int, key1, key2, value int) util.Unit {
	return util.Unit{}
}

// axiom_map_remove_domain -> RemoveEquivalency

// Removing a key-value pair from a dictionary does not change the value mapped to
// by any other keys in the map.
ghost
requires key1 in domain(d)
requires key1 != key2
ensures Remove(d, key2)[key1] == d[key1]
decreases
pure func RemoveDifferent(d dict[int]int, key1, key2 int) util.Unit {
	return util.Unit{}
}

// Two maps are equivalent if their domains are equivalent and every key in their
// domains map to the same value.
ghost
ensures (d1 == d2) ==
	(domain(d1) == domain(d2) && forall x int :: {d1[x], d2[x]} x in domain(d1) ==>	d1[x] == d2[x])
decreases
pure func ExtEqual(d1, d2 dict[int]int) util.Unit {
	return util.Unit{}
}

// axiom_map_ext_equal_deep: skip (we don't have deep equality)
// Skipped macros

/// Silicon axioms
// The cardinality of a dictionary is non-negative.
ghost
ensures len(d) >= 0
decreases
pure func NonNegativeLen(d dict[int]int) util.Unit {
	return util.Unit{}
}

// The cardinality of a dictionary is equal to the cardinality of its domain.
ghost
ensures len(d) == len(domain(d))
decreases
pure func DomainLenEq(d dict[int]int) util.Unit {
	return util.Unit{}
}

// If two dictionaries are disjoint there is no key that is in both of their domains.
ghost
requires AreDisjoint(d1, d2)
ensures forall x int :: {x in domain(d1)} {x in domain(d2)} !(x in domain(d1) && x in domain(d2))
decreases
pure func DisjointNoSharedKey(d1, d2 dict[int]int) util.Unit {
	return util.Unit{}
}

// If two dictionaries are not disjoint, there exists a key that is in both of their domains.
ghost
requires !AreDisjoint(d1, d2)
ensures exists x int :: x in domain(d1) && x in domain(d2)
decreases
pure func NotDisjointSharedKey(d1, d2 dict[int]int) util.Unit {
	return util.Unit{}
}

// There is only one empty map.
ghost
requires IsEmpty(d)
ensures d == Empty()
decreases
pure func EmptyIsUnique(d dict[int]int) util.Unit {
	return util.Unit{}
}

// An empty dictionary contains no keys.
ghost
requires IsEmpty(d)
ensures !(x in domain(d))
decreases
pure func NotInEmpty(d dict[int]int, x int) util.Unit {
	return util.Unit{}
}

// There exists a key in a non-empty dictionary.
ghost
requires !IsEmpty(d)
ensures exists x int :: x in domain(d)
decreases
pure func NotEmptyKeyExists(d dict[int]int, x int) util.Unit {
	return util.Unit{}
}

// If a key is in d, d is not empty.
ghost
requires x in domain(d)
ensures !IsEmpty(d)
decreases
pure func KeyInDomainDictNotEmpty(d dict[int]int, x int) util.Unit {
	return util.Unit{}
}

// Equality -> ExtEqual
// First update axiom: UpdateSame, UpdateDifference

// Inserting a new key increases the cardinality of the dictionary by 1.
// Updating the value of a key does not change the cardinality.
ghost
ensures x in domain(d) ==> len(d[x = y]) == len(d)
ensures !(x in domain(d)) ==> len(d[x = y]) == len(d) + 1
decreases
pure func InsertUpdateLen(d dict[int]int, x, y int) util.Unit {
	return util.Unit{}
}

// If a value is in the range of a dictionary, there exists a corresponding key.
ghost
requires y in range(d)
ensures exists x int :: x in domain(d) && d[x] == y
decreases
pure func ValueHasKey(d dict[int]int, y int) util.Unit {
	return util.Unit{}
}

// If a value is in the domain of a dictionary, the corresponding value is in its range.
ghost
requires x in domain(d)
ensures d[x] in range(d)
decreases
pure func KeyMapsToRange(d dict[int]int, x int) util.Unit {
	return util.Unit{}
}

// Why3 (fmap)
// ==, extensionality -> ExtEqual
// mem k m -> k in domain(m)
// mapsto k v m -> k in domain(m) && m[k] == v
// mem_mapsto: skip (doesn't seem useful)
// is_empty -> IsEmpty
// mk, mk_*: skip (construction doesn't apply)
// empty, is_empty_empty -> Empty
// [<-], add k v m -> m[k = v]
// add_contents_k -> UpdateSame
// add_contents_other -> UpdateDifferent
// add_domain -> InsertDomain
// find k, find_def -> m[k]
// remove k m -> Remove(m, k)
// remove_contents -> RemoveDifferent
// remove_domain -> RemoveDomain
// size m -> len(m)

// NOTE fmap (applicative maps) may be interesting when implementing gomaps

// Why3 (map)
// [], get f x -> f[x]
// [<-], set f x v -> f[x = v]
// const: skip (cannot come up with feasible implementation)
// ==, extensionality -> ExtEqual
// sorted_sub -> IsMonotonicFromTo

// True iff a dictionary is monotonic. Only considers keys in the interval [start, end).
ghost
opaque
decreases
pure func IsMonotonicFromTo(d dict[int]int, start, end int) bool {
	return forall x, y int :: {d[x], d[y]} (x in domain(d) && y in domain(d) && start <= x && x <= y && y < end) ==>
		d[x] <= d[y]
}

// map_eq_sub -> IsEqualFromTo

// True iff two dictionaries are equal in the interval [start, end).
ghost
opaque
decreases
pure func IsEqualFromTo(d1, d2 dict[int]int, start, end int) bool {
	return forall x int :: {d1[x], d2[x]} (start <= x && x < end) ==>
		x in domain(d1) && x in domain(d2) && d1[x] == d2[x]
}

// exchange, exchange_set -> Swap
// NOTE Why3's exchange accepts an interval, while our implementation does not; it is
// probably possible to get the same or similar behavior using Restrict.

// Returns a dictionary with the values at k1 and k2 swapped.
ghost
requires k1 in domain(d) && k2 in domain(d)
ensures domain(result) == domain(d)
ensures result[k1] == d[k2] && result[k2] == d[k1]
ensures forall k int :: {result[k]} (k in domain(d) && k != k1 && k != k2) ==>
	result[k] == d[k]
decreases
pure func Swap(d dict[int]int, k1, k2 int) (result dict[int]int) {
	return d[k1 = d[k2]][k2 = d[k1]]
}

// sum: skip (no sum operation available for sets)

// TODO Continue with number of occurrences (maybe useful to define a function which
// returns the set of keys with the same value and then take the cardinality of that;
// may be useful also for Invert.

// TODO Convert quantifier in spec to argument if possible
// (check sets.gobra and seqs.gobra; probably only keep it if it is part of
// a definition, not a property
// TODO Make naming of variables consistent (e.g. how we name keys and values)
// TODO Organize definitions: Remove duplicates, merge similar ones, place related ones together
