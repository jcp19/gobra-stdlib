/*
  This file is part of gobra-libs which is released under the MIT license.
  See LICENSE or go to https://github.com/viperproject/gobra-libs/blob/main/LICENSE
  for full license details.

  This file is inspired by the standard libraries and axiomatisations of the following verifiers:
  - dafny-lang/dafny: https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/src/Std/Collections/Map.dfy
*/

// This package defines lemmas for mathematical maps (aka dictionaries) commonly used
// in specifications.
package dicts

import "util"
import "sets"

/// Dafny
// Skip Get: No Option<>
// Skip ToImap: No Imap

// A dictionary is empty if its (domain's) cardinality is zero.
ghost
decreases
pure func IsEmpty(d dict[int]int) bool {
	return len(d) == 0
}

// Returns the empty dictionary.
ghost
ensures IsEmpty(result)
decreases
pure func Empty() (result dict[int]int) {
	return dict[int]int{}
}

// QUES We structure Remove, RemoveKeys and Restrict a bit differently
// than Dafny. Are the differences ok?

// Keep all key-value pairs corresponding to the set of keys provided.
ghost
ensures forall x int :: {result[x]} (x in domain(d) && x in xs) ==>
	(x in domain(result) && result[x] == d[x])
ensures forall x int :: {x in domain(result)} x in domain(result) ==>
	(x in domain(d) && x in xs)
ensures domain(result) == xs intersection domain(d)
opaque
decreases xs
pure func Restrict(d dict[int]int, xs set[int]) (result dict[int]int) {
	return let ys := (xs intersection domain(d)) in
		(sets.IsEmpty(ys) ? Empty() :
			(let y := sets.Choose(ys) in
			(let yr := sets.Remove(ys, y) in
			(let _ := sets.IntersectLenUpper(xs, domain(d)) in
			 Restrict(d, yr)[y = d[y]]))))
}

// Remove all key-value pairs corresponding to the set of keys provided.
ghost
decreases
pure func RemoveKeys(d dict[int]int, xs set[int]) (result dict[int]int) {
	return Restrict(d, domain(d) setminus xs)
}

// Remove a key-value pair. Returns unmodified dictionary if key is not found.
ghost
ensures len(result) <= len(d)
ensures x in domain(d) ==> len(result) == len(d) - 1
ensures !(x in domain(d)) ==> len(result) == len(d)
decreases
// QUES For these properties a proof is required. There are few things we can do:
// - Separate properties into different lemma: Calling remove doesnt call its proof, but it is less convenient.
// - Make RemoveKeys(d, sets.SingletonSet(x)) part of the spec and make the function opaque:
//   This would make the API a bit inconsistent (RemoveKeys for example doesn't have that) - although we could change RemoveKeys accordingly (seems like this is what Dafny does)
// - Keep it as is: Whenever someone calls Remove, the proof is instantiated as well.
pure func Remove(d dict[int]int, x int) (result dict[int]int) {
	return let ys := (sets.Remove(domain(d), x)) in
		let _ := util.Asserting(ys intersection domain(d) == ys) in
		RemoveKeys(d, sets.SingletonSet(x))
}

// True iff x maps to the same value or does not exist in d1 and d2.
ghost
decreases
pure func IsEqualOnKey(d1, d2 dict[int]int, x int) bool {
	return !(x in domain(d1) || x in domain(d2)) || (x in domain(d1) && x in domain(d2) && d1[x] == d2[x])
}

// True iff and only if d1 is a subset of d2.
ghost
decreases
pure func IsSubset(d1, d2 dict[int]int) bool {
	return domain(d1) subset domain(d2) &&
		forall x int :: {IsEqualOnKey(d1, d2, x)} {x in domain(d1)} (x in domain(d1)) ==>
		IsEqualOnKey(d1, d2, x)
}

// Union of two dictionaries. Does not require disjoint domains: on the intersection,
// values from the second dictionary are chosen.
ghost
ensures domain(result) == domain(d1) union domain(d2)
ensures forall x int :: {result[x]} (x in domain(d2)) ==> result[x] == d2[x]
ensures forall x int :: {result[x]}  (!(x in domain(d2)) && x in domain(d1)) ==>
	result[x] == d1[x]
opaque
decreases domain(d1) union domain(d2)
pure func Union(d1, d2 dict[int]int) (result dict[int]int) {
	return let xs := domain(d1) union domain(d2) in
		(sets.IsEmpty(xs) ? Empty() :
			let x := sets.Choose(xs) in
			let c1 := Remove(d1, x) in
			let c2 := Remove(d2, x) in
			let _ := sets.RemoveUnionLen(domain(d1), domain(d2), x) in
			(x in domain(d2) ? Union(c1, c2)[x = d2[x]] : Union(c1, c2)[x = d1[x]]))
}

ghost
requires sets.AreDisjoint(domain(d1), domain(d2))
ensures len(Union(d1, d2)) == len(d1) + len(d2)
decreases
pure func DisjointUnionLen(d1, d2 dict[int]int) util.Unit {
	return util.Unit{}
}

// True iff a dictionary is injective.
ghost
opaque
decreases
pure func IsInjective(d dict[int]int) bool {
	return forall x, y int :: {d[x], d[y]} (x != y && x in domain(d) && y in domain(d)) ==>
		d[x] == d[y]
}

// TODO: Go through the Dafny version again, which is quite different.
// Dafny's Invert is opaque and has
// map y | y in m.Values :: var x :| x in m.Keys && m[x] == y; x as its body.
// TODO: make opaque?
// Swap dictionary keys and values. Values are not required to be unique: no promises
// on which key is chosen on the intersection.
ghost
// QUES Shouldn't decreases d be equivalent to this (or at least fail type checking?)
decreases len(d)
pure func Invert(d dict[int]int) (result dict[int]int) {
	return IsEmpty(d) ? Empty() :
		(let key := sets.Choose(domain(d)) in
		(let c := Remove(d, key) in
		Invert(c)[d[key] = key]))
}
